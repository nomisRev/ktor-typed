# Ktor-Typed

A type-safe API framework for Ktor applications, inspired by Tapir and FastAPI, providing automatic parameter
extraction, validation, and serialization.

## Overview

Ktor-Typed is a library that enables you to define type-safe APIs in Kotlin with a focus on:

- **Type Safety**: Compile-time type checking for all API parameters
- **Automatic Validation**: Built-in validation for parameters with clear error messages
- **Clean Syntax**: Property delegation for parameter extraction
- **Code Generation**: Reduces boilerplate through KSP
- **Framework Integration**: Seamless integration with Ktor server and client

The library consists of several modules:

1. **typed-api**: Core module with endpoint definitions and validation
2. **ktor-typed-api**: Ktor-specific implementation
3. **spring-webflux-typed-api**: Spring WebFlux-specific implementation
4. **typed-api-ksp**: Kotlin Symbol Processing for code generation
5. **typed-api-docs**: OpenAPI documentation generation
6. **parser**: OpenAPI model classes and parsing

## Features

- Type-safe endpoint definitions
- Automatic parameter extraction from path, query, headers, and body
- Comprehensive validation system
- Rich metadata for documentation
- Client-side request building
- Code generation to reduce boilerplate

## Installation

Add the following to your `build.gradle.kts`:

```kotlin
plugins {
    id("com.google.devtools.ksp") version "2.1.21-2.0.2" // For code generation
}

dependencies {
    implementation(project(":typed-api"))
    implementation(project(":ktor-typed-api"))
    ksp(project(":typed-api-ksp"))

    // Optional modules
    // implementation(project(":spring-webflux-typed-api")) // For Spring WebFlux integration
    // implementation(project(":typed-api-docs")) // For OpenAPI documentation generation
}
```

## Basic Usage

### Defining an API Endpoint

```kotlin
@Endpoint("/users/{userId}")
class UserApi(api: EndpointAPI) {
    val userId by api.path<Int>(
        validation = Validation.int().min(1, "User ID must be positive")
    )
    val name by api.query<String>()
    val token by api.header<String>()
    val userData by api.body<UserData>()
}

@Serializable
data class UserData(val email: String, val age: Int)
```

### Server-side Implementation

#### Ktor

```kotlin
routing {
    post(::UserApi) { api ->
        // Access typed parameters
        val user = userService.createUser(id = api.userId, name = api.name, token = api.token, data = api.userData)
        call.respond(HttpStatusCode.OK, user)
    }
}
```

#### Spring WebFlux

```kotlin
router {
    POST(::UserApi) { api ->
        // Access typed parameters
        val user = userService.createUser(id = api.userId, name = api.name, token = api.token, data = api.userData)
        ServerResponse.ok()
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(ServerTestResponse(id = api.id, name = api.name, message = "Success"))
    }
}
```

### Client-side Usage

Using the same `UserApi` from the client side requires a little-bit of boilerplate code,
but this is automatically generated by KSP! In this case `User` was generated for `UserApi`.

#### Ktor

```kotlin
suspend fun HttpClient.postUser(): UserResponse =
    post(User(
        userId = 123,
        name = "John Doe",
        token = "auth-token",
        userData = UserData("john@example.com", 30)
    ).request()).body<UserResponse>()
```

#### Spring WebFlux



If you're not using KSP for the boilerplate generation, you can also manually define the wiring code.
You can also use the `properties()` utility function to conveniently construct the properties map for a Request:

```kotlin
val request = Request(
    params,
    ::UserApi,
    properties = properties(
        UserParams::userId,
        UserParams::name,
        UserParams::token,
        UserParams::userData
    )
)
```

## Validation

The library provides a comprehensive validation system:

```kotlin
val age by query<Int>(
    validation = Validation.int()
        .min(18, "Must be at least 18 years old")
        .max(150, "Must be a reasonable age")
)

val email by query<String>(
    validation = Validation.email("Must be a valid email address")
)

val username by query<String>(
    validation = Validation.string()
        .minLength(3, "Username too short")
        .maxLength(20, "Username too long")
        .alphanumeric("Username must be alphanumeric")
)
```

## OpenAPI Documentation (Work In Progress)

The library provides functionality to generate OpenAPI documentation from your endpoints:

```kotlin
// Define your API info
val apiInfo = Info(
    title = "My API",
    version = "1.0.0",
    description = "API for managing users"
)

// Generate OpenAPI documentation
val openAPI = generateOpenAPI<UserApi>(
    info = apiInfo,
    ::UserApi
)

// Convert to JSON or YAML
val json = Json.encodeToString(openAPI)
```

This generates OpenAPI documentation with path items, operations, parameters, and schemas based on your endpoint
definitions.

## Modules

### typed-api

The core module provides the foundation for building type-safe APIs with a focus on validation and metadata support. It
includes:

- Property delegation syntax for parameter extraction
- Comprehensive validation system
- Rich metadata for documentation

### ktor-typed-api

This module provides Ktor-specific implementation of the Typed API framework, including:

- Integration with Ktor's routing system
- Client-side request building
- Server-side parameter extraction

### typed-api-ksp

This module contains a Kotlin Symbol Processor (KSP) that generates boilerplate code for client support:

- Generates data classes from `@Endpoint` classes
- Creates `request()` functions for client usage
- Maps property names to KProperty1 references

### spring-webflux-typed-api

This module provides Spring WebFlux-specific implementation of the Typed API framework, including:

- Integration with Spring WebFlux's routing system
- Client-side request building with WebClient
- Server-side parameter extraction

### typed-api-docs

This module provides functionality to generate OpenAPI documentation from Typed API endpoints:

- Creates OpenAPI specifications with path items, operations, parameters, and schemas
- Supports documenting endpoints with metadata
- Integrates with the parser module for OpenAPI model classes

### parser

This module contains OpenAPI model classes and parsing functionality:

- Provides data classes for OpenAPI 3.x specification
- Supports JSON and YAML parsing
- Used by the typed-api-docs module for documentation generation

## Requirements

- Kotlin 2.1.21+
- Ktor 3.1.3+
- KSP 2.1.21-2.0.2+ (for code generation)

## License

[Apache 2.0](LICENSE)
